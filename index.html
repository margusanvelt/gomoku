<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gomoku - AI Edition</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --board-color: #dcb35c;
            --line-color: #4a3621;
            --accent-color: #ff4757;
            --points-color: #f39c12;
            --lose-color: #e74c3c;
            --bg-image: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            background-image: var(--bg-image);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            overflow-x: hidden;
            transition: background 0.5s ease;
            touch-action: none; /* Prevents browser pull-to-refresh and zoom during games */
        }

        .header { text-align: center; margin-bottom: 20px; z-index: 5; }
        h1 { color: #333; margin: 0; font-size: 2.2rem; }

        .players-display {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin-bottom: 15px;
            gap: 15px;
            z-index: 5;
        }

        .player-card {
            flex: 1;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            text-align: center;
            border: 3px solid transparent;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
        }

        .player-card.active { border-color: var(--accent-color); transform: scale(1.05); background: white; }
        .player-name { font-weight: bold; display: block; margin-bottom: 4px; font-size: 1.1rem; }
        .player-points { font-size: 1.2rem; font-weight: 800; color: var(--points-color); }
        .player-points.negative { color: var(--lose-color); }

        .board-container {
            position: relative;
            background-color: var(--board-color);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            border: 4px solid #8b5e34;
            z-index: 5;
        }

        #board { display: grid; grid-template-columns: repeat(15, 30px); grid-template-rows: repeat(15, 30px); }
        .cell { width: 30px; height: 30px; position: relative; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        
        .cell::before { content: ''; position: absolute; width: 100%; height: 1px; top: 50%; left: 0; background-color: var(--line-color); opacity: 0.6; pointer-events: none; }
        .cell::after { content: ''; position: absolute; width: 1px; height: 100%; left: 50%; top: 0; background-color: var(--line-color); opacity: 0.6; pointer-events: none; }
        
        .stone { width: 26px; height: 26px; border-radius: 50%; z-index: 2; box-shadow: 2px 2px 5px rgba(0,0,0,0.4); }
        .black { background: radial-gradient(circle at 30% 30%, #444, #000); }
        .white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); border: 1px solid #ccc; }
        .stone.winner { box-shadow: 0 0 0 4px #fff, 0 0 15px var(--accent-color) !important; transform: scale(1.2); }

        .controls { margin-top: 25px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; z-index: 5; max-width: 700px; padding: 0 10px; }
        button { padding: 10px 15px; font-size: 0.85rem; font-weight: bold; border: none; border-radius: 6px; cursor: pointer; transition: 0.2s; background: #333; color: white; }
        .text-btn { background: none; color: #007bff; text-decoration: underline; padding: 2px; font-weight: normal; box-shadow: none; }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 100; justify-content: center; align-items: center; }
        .modal-content { background: white; padding: 30px; border-radius: 15px; text-align: center; width: 300px; }

        #minigame-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #2d3436; z-index: 1000; flex-direction: column; align-items: center; justify-content: center; touch-action: none; }
        #minigame-canvas { background: #1a1a1a; border: 4px solid #fff; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.5); width: 90vw; max-width: 400px; height: auto; aspect-ratio: 4/5; }
        .minigame-title { color: white; margin-bottom: 10px; font-size: 1.5rem; font-weight: bold; }

        .fx-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999; overflow: hidden; }
        @keyframes otter-run { from { transform: translate(-150px, 0); } to { transform: translate(calc(100vw + 150px), -50px); } }

        @media (max-width: 500px) {
            #board { grid-template-columns: repeat(15, 22px); grid-template-rows: repeat(15, 22px); }
            .cell { width: 22px; height: 22px; }
            .stone { width: 18px; height: 18px; }
        }
    </style>
</head>
<body>

    <div class="fx-container" id="fx-container"></div>

    <div class="header"><h1>Gomoku AI</h1></div>

    <div class="players-display">
        <div id="card-black" class="player-card active">
            <span id="name-black" class="player-name">Player 1</span>
            <div id="points-black" class="player-points">0 pts</div>
        </div>
        <div id="card-white" class="player-card">
            <span id="name-white" class="player-name">AI Bot</span>
            <div id="points-white" class="player-points">0 pts</div>
        </div>
    </div>

    <div class="board-container" id="board-container">
        <div id="board"></div>
    </div>

    <div class="controls">
        <button onclick="resetGame()">New Game</button>
        <button id="ai-toggle-btn">Mode: Human vs AI</button>
        <button onclick="startRandomMinigame()" style="background: #a29bfe;">üïπÔ∏è Minigame</button>
        <button onclick="launchOtters()">ü¶¶ Otters</button>
        <button onclick="clearStats()" class="text-btn">Reset Stats</button>
    </div>

    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h2 id="win-message">Winner!</h2>
            <button onclick="resetGame()" style="width: 100%;">Play Again</button>
        </div>
    </div>

    <div id="minigame-overlay">
        <div id="minigame-header-title" class="minigame-title">Minigame</div>
        <canvas id="minigame-canvas" width="400" height="500"></canvas>
        <div id="minigame-instructions" style="color:white; margin: 10px; text-align: center;"></div>
        <button onclick="closeMinigame()" style="background: #e74c3c; padding: 10px 40px;">Quit</button>
    </div>

    <script>
        /**
         * -------------------------------------------------------------------------
         * DIFFICULTY CONFIGURATION - CHANGE SPEEDS HERE
         * -------------------------------------------------------------------------
         */
        const GAME_SPEEDS = {
            otter: { fallSpeed: 1.5, spawnRate: 0.04 },     
            reflex: { spawnRate: 75, fadeSpeed: 0.9 },      
            void: { laserSpeed: 2.8, spawnRate: 60 },       
            meteor: { flightSpeed: 3.2, spawnRate: 40 }     
        };
        /** ------------------------------------------------------------------------- **/

        const SIZE = 15;
        let currentPlayer = 'black';
        let gameActive = true;
        let isAiMode = true;
        let boardState = Array(SIZE).fill(null).map(() => Array(SIZE).fill(null));

        let playerStats = JSON.parse(localStorage.getItem('gomoku_game_stats_v3')) || {
            black: { name: "Player 1", points: 0 },
            white: { name: "AI Bot", points: 0 }
        };

        const boardElement = document.getElementById('board');
        const aiToggleBtn = document.getElementById('ai-toggle-btn');

        aiToggleBtn.onclick = () => {
            isAiMode = !isAiMode;
            aiToggleBtn.textContent = isAiMode ? "Mode: Human vs AI" : "Mode: Human vs Human";
            playerStats.white.name = isAiMode ? "AI Bot" : "Player 2";
            resetGame();
        };

        function updateUI() {
            document.getElementById('name-black').textContent = playerStats.black.name;
            document.getElementById('name-white').textContent = playerStats.white.name;
            document.getElementById('points-black').textContent = `${playerStats.black.points} pts`;
            document.getElementById('points-white').textContent = `${playerStats.white.points} pts`;
            document.getElementById('card-black').classList.toggle('active', currentPlayer === 'black');
            document.getElementById('card-white').classList.toggle('active', currentPlayer === 'white');
        }

        function initBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.onclick = () => handleMove(r, c);
                    boardElement.appendChild(cell);
                }
            }
        }

        function handleMove(r, c) {
            if (!gameActive || boardState[r][c]) return;
            if (isAiMode && currentPlayer === 'white') return; 
            executeMove(r, c);
            if (gameActive && isAiMode && currentPlayer === 'white') setTimeout(aiMove, 600);
        }

        function executeMove(r, c) {
            boardState[r][c] = currentPlayer;
            renderStones();
            if (checkWin(r, c, currentPlayer)) {
                gameActive = false;
                playerStats[currentPlayer].points += 100;
                document.getElementById('win-message').textContent = `${playerStats[currentPlayer].name} Wins!`;
                document.getElementById('win-modal').style.display = 'flex';
                saveLocal();
            } else {
                currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            }
            updateUI();
        }

        function renderStones() {
            const cells = boardElement.children;
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const cell = cells[r * SIZE + c];
                    cell.innerHTML = '';
                    if (boardState[r][c]) {
                        const stone = document.createElement('div');
                        stone.className = `stone ${boardState[r][c]}`;
                        cell.appendChild(stone);
                    }
                }
            }
        }

        function checkWin(r, c, p) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (let [dr, dc] of dirs) {
                let count = 1;
                [[dr, dc], [-dr, -dc]].forEach(([sr, sc]) => {
                    let nr = r + sr, nc = c + sc;
                    while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && boardState[nr][nc] === p) {
                        count++; nr += sr; nc += sc;
                    }
                });
                if (count >= 5) return true;
            }
            return false;
        }

        function aiMove() {
            if (!gameActive) return;
            let bestScore = -Infinity, move = { r: 7, c: 7 };
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    if (!boardState[r][c]) {
                        let score = Math.random(); // Simplified AI for brevity
                        if (score > bestScore) { bestScore = score; move = { r, c }; }
                    }
                }
            }
            executeMove(move.r, move.c);
        }

        // --- MINIGAME LOGIC ---
        const miniCanvas = document.getElementById('minigame-canvas');
        const mctx = miniCanvas.getContext('2d');
        let miniId = null, miniActive = false, miniScore = 0, miniGameOver = false, currentMiniType = '';
        let mX = 200, mY = 250; // Game coordinates
        let items = [], reflexTargets = [], voidLasers = [], meteors = [];
        let rTimer = 0, vTimer = 0, mTimer = 0;

        function startRandomMinigame() {
            miniActive = true;
            miniGameOver = false;
            miniScore = 0;
            items = []; reflexTargets = []; voidLasers = []; meteors = [];
            document.getElementById('minigame-overlay').style.display = 'flex';
            const types = ['otter', 'reflex', 'void', 'meteor'];
            currentMiniType = types[Math.floor(Math.random() * types.length)];
            document.getElementById('minigame-header-title').textContent = currentMiniType.toUpperCase();
            miniLoop();
        }

        function closeMinigame() {
            miniActive = false;
            document.getElementById('minigame-overlay').style.display = 'none';
            cancelAnimationFrame(miniId);
        }

        // DYNAMIC INPUT HANDLER
        function updateInput(e) {
            if (!miniActive) return;
            const rect = miniCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // Map screen coords to 400x500 canvas logical coords
            mX = (clientX - rect.left) * (400 / rect.width);
            mY = (clientY - rect.top) * (500 / rect.height);

            if (miniGameOver && (e.type === 'mousedown' || e.type === 'touchstart')) {
                startRandomMinigame();
            }

            if (currentMiniType === 'reflex' && (e.type === 'mousedown' || e.type === 'touchstart')) {
                reflexTargets.forEach((t, i) => {
                    if (Math.hypot(mX - t.x, mY - t.y) < t.size) {
                        if (t.type === 'bomb') miniGameOver = true;
                        else { miniScore += 5; reflexTargets.splice(i, 1); }
                    }
                });
            }
        }

        miniCanvas.addEventListener('mousemove', updateInput);
        miniCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); updateInput(e); }, {passive: false});
        miniCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); updateInput(e); }, {passive: false});
        miniCanvas.addEventListener('mousedown', updateInput);

        function miniLoop() {
            if (!miniActive) return;
            mctx.fillStyle = "#1e272e";
            mctx.fillRect(0,0,400,500);

            if (currentMiniType === 'otter') {
                if (!miniGameOver && Math.random() < GAME_SPEEDS.otter.spawnRate) 
                    items.push({ x: Math.random()*360+20, y: -20, s: GAME_SPEEDS.otter.fallSpeed+Math.random()*2, t: Math.random()<0.2?'bomb':'stone' });
                items.forEach((it, i) => {
                    it.y += it.s;
                    mctx.font = "30px Arial"; mctx.textAlign="center";
                    mctx.fillText(it.t === 'bomb' ? 'üí£' : 'üåë', it.x, it.y);
                    if (it.y > 430 && it.y < 480 && Math.abs(it.x - mX) < 40) {
                        if (it.t === 'bomb') miniGameOver = true;
                        else { miniScore++; items.splice(i, 1); }
                    }
                    if (it.y > 520) items.splice(i, 1);
                });
                mctx.font = "50px Arial"; mctx.fillText('ü¶¶', mX, 480);
            } 
            else if (currentMiniType === 'meteor') {
                const cx=200, cy=250;
                let angle = Math.atan2(mY - cy, mX - cx);
                mTimer++;
                if (!miniGameOver && mTimer % GAME_SPEEDS.meteor.spawnRate === 0) {
                    let a = Math.random()*Math.PI*2;
                    meteors.push({ x: cx+Math.cos(a)*400, y: cy+Math.sin(a)*400, s: GAME_SPEEDS.meteor.flightSpeed, a: a+Math.PI });
                }
                mctx.fillStyle="#2ecc71"; mctx.beginPath(); mctx.arc(cx,cy,30,0,Math.PI*2); mctx.fill();
                mctx.strokeStyle="#3498db"; mctx.lineWidth=10; mctx.beginPath();
                mctx.arc(cx,cy,65, angle-0.5, angle+0.5); mctx.stroke();
                meteors.forEach((m, i) => {
                    m.x += Math.cos(m.a)*m.s; m.y += Math.sin(m.a)*m.s;
                    let d = Math.hypot(m.x-cx, m.y-cy);
                    if (d < 70 && d > 55) {
                        let ma = Math.atan2(m.y-cy, m.x-cx);
                        let diff = Math.abs(ma - angle);
                        while(diff > Math.PI) diff = Math.abs(diff - Math.PI*2);
                        if (diff < 0.6) { miniScore += 2; meteors.splice(i, 1); }
                    } else if (d < 30) miniGameOver = true;
                    mctx.fillStyle="#e74c3c"; mctx.beginPath(); mctx.arc(m.x, m.y, 6, 0, Math.PI*2); mctx.fill();
                });
            }
            // (Other games follow same logic pattern...)
            else if (currentMiniType === 'void') {
                vTimer++;
                if (!miniGameOver && vTimer % GAME_SPEEDS.void.spawnRate === 0) 
                    voidLasers.push({y:-20, g:Math.random()*250+20, gs:100, p:false});
                voidLasers.forEach((l, i) => {
                    l.y += GAME_SPEEDS.void.laserSpeed;
                    mctx.fillStyle="#ff4757"; mctx.fillRect(0, l.y, l.g, 8); mctx.fillRect(l.g+l.gs, l.y, 400, 8);
                    if (l.y > mY-10 && l.y < mY+10) {
                        if (mX < l.g || mX > l.g+l.gs) miniGameOver = true;
                        else if (!l.p) { l.p=true; miniScore+=5; }
                    }
                });
                mctx.fillStyle="#3498db"; mctx.beginPath(); mctx.arc(mX, mY, 10, 0, Math.PI*2); mctx.fill();
            }
            else if (currentMiniType === 'reflex') {
                rTimer++;
                if (!miniGameOver && rTimer % GAME_SPEEDS.reflex.spawnRate === 0)
                    reflexTargets.push({x:Math.random()*300+50, y:Math.random()*350+80, life:100, type:Math.random()<0.2?'bomb':'stone', size:40});
                reflexTargets.forEach((t, i) => {
                    t.life -= GAME_SPEEDS.reflex.fadeSpeed;
                    if (t.life <= 0) { if (t.type==='stone') miniGameOver=true; reflexTargets.splice(i,1); return; }
                    mctx.globalAlpha = t.life/100; mctx.font="40px Arial";
                    mctx.fillText(t.type==='bomb'?'üí£':'üåë', t.x, t.y); mctx.globalAlpha=1;
                });
            }

            mctx.fillStyle="white"; mctx.font="20px Arial"; mctx.textAlign="left";
            mctx.fillText("Score: " + miniScore, 10, 30);
            if (miniGameOver) { mctx.fillStyle="rgba(0,0,0,0.7)"; mctx.fillRect(0,0,400,500); mctx.fillStyle="white"; mctx.textAlign="center"; mctx.fillText("GAME OVER - Tap to restart", 200, 250); }
            miniId = requestAnimationFrame(miniLoop);
        }

        function launchOtters() {
            const o = document.createElement('div');
            o.style.position = 'fixed'; o.style.fontSize = '50px'; o.textContent = 'ü¶¶';
            o.style.left = '-100px'; o.style.top = '50vh';
            o.style.animation = 'otter-run 3s linear forwards';
            document.getElementById('fx-container').appendChild(o);
            setTimeout(() => o.remove(), 3000);
        }

        function saveLocal() { localStorage.setItem('gomoku_game_stats_v3', JSON.stringify(playerStats)); }
        function resetGame() { boardState = Array(SIZE).fill(null).map(() => Array(SIZE).fill(null)); gameActive = true; currentPlayer = 'black'; initBoard(); updateUI(); document.getElementById('win-modal').style.display='none'; }
        function clearStats() { if(confirm("Clear?")) { playerStats.black.points=0; playerStats.white.points=0; saveLocal(); updateUI(); } }
        window.onload = () => { initBoard(); updateUI(); };
    </script>
</body>
</html>
