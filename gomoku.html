<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gomoku - AI Edition</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --board-color: #dcb35c;
            --line-color: #4a3621;
            --accent-color: #ff4757;
            --points-color: #f39c12;
            --lose-color: #e74c3c;
            --bg-image: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            background-image: var(--bg-image);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            overflow-x: hidden;
            transition: background 0.5s ease;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            z-index: -1;
            pointer-events: none;
        }

        .header { text-align: center; margin-bottom: 20px; z-index: 5; }
        h1 { color: #333; margin: 0; font-size: 2.2rem; text-shadow: 0 2px 4px rgba(255,255,255,0.5); }

        .players-display {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin-bottom: 15px;
            gap: 15px;
            z-index: 5;
        }

        .player-card {
            flex: 1;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            text-align: center;
            border: 3px solid transparent;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
        }

        .player-card.active { border-color: var(--accent-color); transform: scale(1.05); background: white; }
        .player-name { font-weight: bold; display: block; margin-bottom: 4px; font-size: 1.1rem; }
        .player-points { font-size: 1.2rem; font-weight: 800; color: var(--points-color); }
        .player-points.negative { color: var(--lose-color); }

        .board-container {
            position: relative;
            background-color: var(--board-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            border: 4px solid #8b5e34;
            z-index: 5;
            transition: background-color 0.4s, border-color 0.4s;
        }

        #board { display: grid; grid-template-columns: repeat(15, 30px); grid-template-rows: repeat(15, 30px); }
        .cell { width: 30px; height: 30px; position: relative; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        
        .cell::before, .cell::after { 
            content: ''; 
            position: absolute; 
            background-color: var(--line-color); 
            opacity: 0.6; 
            transition: background-color 0.4s; 
            pointer-events: none;
        }
        .cell::before { width: 100%; height: 1px; top: 50%; left: 0; }
        .cell::after { width: 1px; height: 100%; left: 50%; top: 0; }
        
        .cell.top::after { height: 50%; top: 50%; }
        .cell.bottom::after { height: 50%; top: 0; }
        .cell.left::before { width: 50%; left: 50%; }
        .cell.right::before { width: 50%; left: 0; }

        .stone { width: 26px; height: 26px; border-radius: 50%; z-index: 2; box-shadow: 2px 2px 5px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; font-size: 18px; transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        .style-0.black { background: radial-gradient(circle at 30% 30%, #444, #000); }
        .style-0.white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); border: 1px solid #ccc; }
        .style-1.black { background: #9b59b6; box-shadow: 0 0 10px #9b59b6; border: 2px solid #fff; }
        .style-1.white { background: #1abc9c; box-shadow: 0 0 10px #1abc9c; border: 2px solid #fff; }
        .style-2.black { background: linear-gradient(135deg, #e74c3c, #c0392b); border-radius: 4px; transform: rotate(45deg); width: 20px; height: 20px; }
        .style-2.white { background: linear-gradient(135deg, #3498db, #2980b9); border-radius: 4px; transform: rotate(45deg); width: 20px; height: 20px; }
        .style-3 { background: none !important; box-shadow: none !important; }
        .style-4.black { background: #222; border: 2px solid #444; }
        .style-4.white { background: #eee; border: 2px solid #ccc; }

        .stone.winner { 
            box-shadow: 0 0 0 4px #fff, 0 0 15px var(--accent-color) !important; 
            transform: scale(1.2); 
            z-index: 10;
        }

        .controls { margin-top: 25px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; z-index: 5; max-width: 700px; }
        button { padding: 10px 18px; font-size: 0.85rem; font-weight: bold; border: none; border-radius: 6px; cursor: pointer; transition: 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        button:active { transform: translateY(2px); }
        
        .primary-btn { background-color: #333; color: white; }
        .secondary-btn { background-color: #ddd; color: #333; }
        .danger-btn { background-color: #e74c3c; color: white; }
        .minigame-btn { background-color: #a29bfe; color: white; }
        .stone-btn { background-color: #2ecc71; color: white; }
        .board-btn { background-color: #e67e22; color: white; }
        .ai-btn { background-color: #0984e3; color: white; }
        .text-btn { background: none; color: #007bff; text-decoration: underline; padding: 2px; font-weight: normal; box-shadow: none; }

        .fx-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999; overflow: hidden; }
        .otter-anim { position: absolute; font-size: 50px; }
        .trophy-item { position: absolute; font-size: 40px; }

        @keyframes otter-run {
            from { transform: translate(-150px, 0); }
            to { transform: translate(calc(100vw + 150px), -50px); }
        }
        @keyframes trophy-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(calc(100vh + 100px)) rotate(360deg); opacity: 0.7; }
        }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 100; justify-content: center; align-items: center; }
        .modal-content { background: white; padding: 30px; border-radius: 15px; text-align: center; width: 340px; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }

        #minigame-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #2d3436; z-index: 1000; flex-direction: column; align-items: center; justify-content: center; }
        #minigame-canvas { background: #1a1a1a; border: 4px solid #fff; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .minigame-title { color: white; margin-bottom: 10px; font-size: 1.8rem; font-weight: bold; }

        @media (max-width: 500px) {
            #board { grid-template-columns: repeat(15, 22px); grid-template-rows: repeat(15, 22px); }
            .cell { width: 22px; height: 22px; }
            .stone { width: 18px; height: 18px; }
            #minigame-canvas { width: 90vw; height: auto; }
        }
    </style>
</head>
<body>

    <div class="fx-container" id="fx-container"></div>

    <div class="header">
        <h1>Gomoku AI</h1>
    </div>

    <div class="players-display">
        <div id="card-black" class="player-card active">
            <span id="name-black" class="player-name">Player 1</span>
            <div id="points-black" class="player-points">0 pts</div>
            <button class="text-btn" id="rename-black" onclick="openNickModal('black')">Rename</button>
        </div>
        <div id="card-white" class="player-card">
            <span id="name-white" class="player-name">Player 2</span>
            <div id="points-white" class="player-points">0 pts</div>
            <button class="text-btn" id="rename-white" onclick="openNickModal('white')">Rename</button>
        </div>
    </div>

    <div class="board-container" id="board-container">
        <div id="board"></div>
    </div>

    <div class="controls">
        <button id="reset-btn" class="primary-btn">New Game</button>
        <button id="ai-toggle-btn" class="ai-btn">Mode: Human vs AI</button>
        <button id="draw-btn" class="secondary-btn">Draw</button>
        <button id="giveup-btn" class="danger-btn">Surrender</button>
        <button onclick="cycleStoneStyle()" class="stone-btn">üîò Stones</button>
        <button onclick="cycleBoardStyle()" class="board-btn">üèÅ Board</button>
        <button onclick="cycleWallpaper()" class="secondary-btn">üñºÔ∏è Wallpaper</button>
        <button onclick="startRandomMinigame()" class="minigame-btn">üïπÔ∏è Minigame</button>
        <button onclick="launchOtters()" class="secondary-btn">ü¶¶ Otters</button>
        <button onclick="clearStats()" class="text-btn" style="color:#999; margin-top: 10px; display: block; width: 100%;">Reset Stats</button>
    </div>

    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h2 id="win-message">Winner!</h2>
            <div id="point-summary">
                <p id="winner-gain" style="color:#2ecc71; font-weight:bold;"></p>
                <p id="loser-loss" style="color:#e74c3c; font-weight:bold;"></p>
            </div>
            <button onclick="resetGame()" class="primary-btn" style="margin-top: 15px; width: 100%;">Play Again</button>
        </div>
    </div>

    <div id="draw-confirm-modal" class="modal">
        <div class="modal-content">
            <h2>Offer Draw?</h2>
            <p>Do you want to end this game in a tie?</p>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="handleDrawAccept()" class="primary-btn" style="flex: 1;">Yes, Draw</button>
                <button onclick="closeModals()" class="secondary-btn" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <div id="nick-modal" class="modal">
        <div class="modal-content">
            <h2>Set Name</h2>
            <input type="text" id="nick-input" maxlength="12" style="width: 80%; padding: 12px; margin: 10px 0; border: 1px solid #ccc; border-radius: 4px;">
            <br>
            <button id="nick-save" class="primary-btn" style="width: 45%;">Save</button>
            <button onclick="closeModals()" class="secondary-btn" style="width: 45%;">Cancel</button>
        </div>
    </div>

    <div id="minigame-overlay">
        <div id="minigame-header-title" class="minigame-title">Minigame</div>
        <canvas id="minigame-canvas" width="400" height="500"></canvas>
        <div id="minigame-instructions" style="color:white; margin: 15px 0; text-align: center; max-width: 350px;"></div>
        <button onclick="closeMinigame()" class="danger-btn" style="padding: 12px 30px;">Leave Game</button>
    </div>

    <script>
        const SIZE = 15;
        const WIN_GAIN = 100;
        const LOSS_PENALTY = 25;
        
        let currentPlayer = 'black';
        let gameActive = true;
        let isAiMode = true;
        let boardState = Array(SIZE).fill(null).map(() => Array(SIZE).fill(null));
        let stoneStyleIndex = 0;
        let boardStyleIndex = 0;
        let currentWpIndex = 0;

        const WALLPAPERS = [
            'none',
            'url("https://images.unsplash.com/photo-1541701494587-cb58502866ab?auto=format&fit=crop&w=1600&q=80")',
            'url("https://images.unsplash.com/photo-1550684848-fac1c5b4e853?auto=format&fit=crop&w=1600&q=80")',
            'url("https://images.unsplash.com/photo-1465146344425-f00d5f5c8f07?auto=format&fit=crop&w=1600&q=80")'
        ];

        const BOARD_STYLES = [
            { bg: '#dcb35c', line: '#4a3621', border: '#8b5e34' },
            { bg: '#2c3e50', line: '#3498db', border: '#1a252f' },
            { bg: '#27ae60', line: '#ecf0f1', border: '#1e8449' },
            { bg: '#111', line: '#00ff00', border: '#004400' }
        ];

        let playerStats = JSON.parse(localStorage.getItem('gomoku_game_stats_v3')) || {
            black: { name: "Player 1", points: 0 },
            white: { name: "AI Bot", points: 0 }
        };

        const boardElement = document.getElementById('board');
        const boardContainer = document.getElementById('board-container');
        const fxContainer = document.getElementById('fx-container');
        const aiToggleBtn = document.getElementById('ai-toggle-btn');

        function saveLocal() {
            localStorage.setItem('gomoku_game_stats_v3', JSON.stringify(playerStats));
        }

        aiToggleBtn.onclick = () => {
            isAiMode = !isAiMode;
            aiToggleBtn.textContent = isAiMode ? "Mode: Human vs AI" : "Mode: Human vs Human";
            if (isAiMode) {
                playerStats.white.name = "AI Bot";
                document.getElementById('rename-white').style.display = 'none';
            } else {
                playerStats.white.name = "Player 2";
                document.getElementById('rename-white').style.display = 'inline-block';
            }
            resetGame();
        };

        function cycleWallpaper() {
            currentWpIndex = (currentWpIndex + 1) % WALLPAPERS.length;
            document.body.style.setProperty('--bg-image', WALLPAPERS[currentWpIndex]);
            document.body.style.backgroundColor = WALLPAPERS[currentWpIndex] === 'none' ? '#f0f2f5' : 'transparent';
        }

        function cycleStoneStyle() {
            stoneStyleIndex = (stoneStyleIndex + 1) % 5;
            renderStones();
        }

        function cycleBoardStyle() {
            boardStyleIndex = (boardStyleIndex + 1) % BOARD_STYLES.length;
            const s = BOARD_STYLES[boardStyleIndex];
            document.documentElement.style.setProperty('--board-color', s.bg);
            document.documentElement.style.setProperty('--line-color', s.line);
            boardContainer.style.borderColor = s.border;
        }

        function updateUI() {
            document.getElementById('name-black').textContent = playerStats.black.name;
            document.getElementById('name-white').textContent = playerStats.white.name;
            document.getElementById('points-black').textContent = `${playerStats.black.points} pts`;
            document.getElementById('points-white').textContent = `${playerStats.white.points} pts`;
            
            document.getElementById('points-black').classList.toggle('negative', playerStats.black.points < 0);
            document.getElementById('points-white').classList.toggle('negative', playerStats.white.points < 0);

            document.getElementById('card-black').classList.toggle('active', currentPlayer === 'black');
            document.getElementById('card-white').classList.toggle('active', currentPlayer === 'white');
        }

        function initBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${r===0?'top':''} ${r===SIZE-1?'bottom':''} ${c===0?'left':''} ${c===SIZE-1?'right':''}`;
                    cell.onclick = () => handleMove(r, c);
                    boardElement.appendChild(cell);
                }
            }
        }

        function handleMove(r, c) {
            if (!gameActive || boardState[r][c]) return;
            if (isAiMode && currentPlayer === 'white') return; 

            executeMove(r, c);

            if (gameActive && isAiMode && currentPlayer === 'white') {
                setTimeout(aiMove, 600);
            }
        }

        function executeMove(r, c) {
            boardState[r][c] = currentPlayer;
            renderStones();
            const winLine = checkWin(r, c, currentPlayer);
            if (winLine) {
                endGame(currentPlayer, WIN_GAIN, winLine);
            } else if (boardState.every(row => row.every(cell => cell !== null))) {
                endGame('draw', 0);
            } else {
                currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
                updateUI();
            }
        }

        function renderStones() {
            const cells = boardElement.children;
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const cell = cells[r * SIZE + c];
                    cell.innerHTML = '';
                    if (boardState[r][c]) {
                        const side = boardState[r][c];
                        const stone = document.createElement('div');
                        stone.className = `stone style-${stoneStyleIndex} ${side}`;
                        if (stoneStyleIndex === 3) stone.textContent = side === 'black' ? 'üåë' : 'üåï';
                        cell.appendChild(stone);
                    }
                }
            }
        }

        function checkWin(r, c, p) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (let [dr, dc] of dirs) {
                let line = [[r, c]];
                [[dr, dc], [-dr, -dc]].forEach(([sr, sc]) => {
                    let nr = r + sr, nc = c + sc;
                    while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && boardState[nr][nc] === p) {
                        line.push([nr, nc]);
                        nr += sr; nc += sc;
                    }
                });
                if (line.length >= 5) return line;
            }
            return null;
        }

        function aiMove() {
            if (!gameActive) return;
            let bestScore = -Infinity;
            let move = { r: 7, c: 7 };
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    if (!boardState[r][c]) {
                        let score = evaluatePos(r, c, 'white') + evaluatePos(r, c, 'black') * 1.1;
                        score += (SIZE/2 - Math.abs(r - SIZE/2)) + (SIZE/2 - Math.abs(c - SIZE/2));
                        if (score > bestScore) {
                            bestScore = score;
                            move = { r, c };
                        }
                    }
                }
            }
            executeMove(move.r, move.c);
        }

        function evaluatePos(r, c, p) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            let total = 0;
            for (let [dr, dc] of dirs) {
                let count = 1;
                let block = 0;
                [[dr, dc], [-dr, -dc]].forEach(([sr, sc]) => {
                    let nr = r + sr, nc = c + sc;
                    while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && boardState[nr][nc] === p) {
                        count++;
                        nr += sr; nc += sc;
                    }
                    if (nr < 0 || nr >= SIZE || nc < 0 || nr >= SIZE || (boardState[nr][nc] !== null && boardState[nr][nc] !== p)) {
                        block++;
                    }
                });
                if (count >= 5) total += 100000;
                else if (count === 4 && block === 0) total += 10000;
                else if (count === 4 && block === 1) total += 1000;
                else if (count === 3 && block === 0) total += 500;
                else if (count === 3 && block === 1) total += 100;
                else if (count === 2 && block === 0) total += 50;
            }
            return total;
        }

        function endGame(winner, pts, line = null) {
            gameActive = false;
            const modal = document.getElementById('win-modal');
            if (winner !== 'draw') {
                const loser = winner === 'black' ? 'white' : 'black';
                playerStats[winner].points += WIN_GAIN;
                playerStats[loser].points -= LOSS_PENALTY;
                if (line) {
                    line.forEach(([lr, lc]) => {
                        const cell = boardElement.children[lr * SIZE + lc];
                        if (cell.firstChild) cell.firstChild.classList.add('winner');
                    });
                }
                document.getElementById('win-message').textContent = `${playerStats[winner].name} Wins!`;
                document.getElementById('winner-gain').textContent = `+${WIN_GAIN} pts to ${playerStats[winner].name}`;
                document.getElementById('loser-loss').textContent = `-${LOSS_PENALTY} pts from ${playerStats[loser].name}`;
                launchTrophies();
            } else {
                document.getElementById('win-message').textContent = "It's a Draw!";
                document.getElementById('winner-gain').textContent = "No points awarded.";
                document.getElementById('loser-loss').textContent = "";
            }
            saveLocal();
            updateUI();
            modal.style.display = 'flex';
        }

        function offerDraw() {
            if (!gameActive) return;
            document.getElementById('draw-confirm-modal').style.display = 'flex';
        }

        function handleDrawAccept() {
            closeModals();
            endGame('draw', 0);
        }

        // --- MINIGAME LOGIC (UPDATED PACING & METEOR STRIKE) ---
        let minigameActive = false;
        let miniId = null;
        let currentMiniGameType = null; 
        const miniCanvas = document.getElementById('minigame-canvas');
        const mctx = miniCanvas.getContext('2d');
        
        let miniScore = 0;
        let miniGameOver = false;

        // Shared variables
        let mouseX = 200;
        let mouseY = 480;

        // Otter Catch specific
        let miniOtterX = 200;
        let miniItems = [];
        const OTTER_SPEED = 0.6; 
        const OTTER_SPAWN = 0.02; 

        // Reflex specific
        let reflexTargets = [];
        let reflexTimer = 0;
        let reflexSpawnRate = 120; 
        const REFLEX_DECAY = 0.6; 

        // Avoid the Void specific
        let voidLasers = [];
        let voidTimer = 0;
        const VOID_SPEED = 1.6; // SLIGHTLY SLOWER

        // Meteor Strike specific
        let meteors = [];
        let meteorSpawnTimer = 0;
        let shieldAngle = 0;

        function startRandomMinigame() {
            minigameActive = true;
            document.getElementById('minigame-overlay').style.display = 'flex';
            
            const types = ['otter', 'reflex', 'void', 'meteor'];
            currentMiniGameType = types[Math.floor(Math.random() * types.length)];
            
            resetMiniState();
            
            const titles = {
                otter: "Otter Catch",
                reflex: "Stone Reflex",
                void: "Avoid the Void",
                meteor: "Meteor Strike"
            };
            const instructions = {
                otter: "Catch stones. Avoid bombs!",
                reflex: "Click stones before they fade. Don't click bombs!",
                void: "Navigate through the laser gaps!",
                meteor: "Rotate shield with mouse. Deflect the red meteors!"
            };

            document.getElementById('minigame-header-title').textContent = titles[currentMiniGameType];
            document.getElementById('minigame-instructions').textContent = instructions[currentMiniGameType];
            
            miniCanvas.style.cursor = currentMiniGameType === 'reflex' ? 'crosshair' : 'none';
            
            miniLoop();
        }

        function closeMinigame() {
            minigameActive = false;
            document.getElementById('minigame-overlay').style.display = 'none';
            cancelAnimationFrame(miniId);
        }

        function resetMiniState() {
            miniScore = 0;
            miniGameOver = false;
            miniItems = [];
            reflexTargets = [];
            voidLasers = [];
            meteors = [];
            reflexTimer = 0;
            voidTimer = 0;
            meteorSpawnTimer = 0;
            reflexSpawnRate = 120;
            miniOtterX = 200;
        }

        function miniLoop() {
            if (!minigameActive) return;
            mctx.clearRect(0, 0, 400, 500);

            // Background
            mctx.fillStyle = "#1e272e";
            mctx.fillRect(0,0,400,500);

            if (currentMiniGameType === 'otter') updateOtterCatch();
            else if (currentMiniGameType === 'reflex') updateReflex();
            else if (currentMiniGameType === 'void') updateVoid();
            else if (currentMiniGameType === 'meteor') updateMeteorStrike();

            // Shared Score Display
            mctx.fillStyle = "white";
            mctx.font = "bold 20px Arial";
            mctx.textAlign = 'left';
            mctx.fillText(`Score: ${Math.floor(miniScore)}`, 20, 40);

            if (miniGameOver) {
                mctx.fillStyle = "rgba(0,0,0,0.8)";
                mctx.fillRect(0,0,400,500);
                mctx.fillStyle = "white";
                mctx.textAlign = 'center';
                mctx.font = "bold 30px Arial";
                mctx.fillText("GAME OVER", 200, 230);
                mctx.font = "20px Arial";
                mctx.fillText(`Final Score: ${Math.floor(miniScore)}`, 200, 270);
                mctx.fillText("Click anywhere to restart", 200, 310);
            }

            miniId = requestAnimationFrame(miniLoop);
        }

        function updateOtterCatch() {
            if (!miniGameOver && Math.random() < OTTER_SPAWN) {
                miniItems.push({
                    x: Math.random() * 360 + 20,
                    y: -20,
                    speed: (OTTER_SPEED + Math.random() * 1.5), 
                    type: Math.random() < 0.2 ? 'bomb' : 'stone'
                });
            }
            miniItems.forEach((item, index) => {
                item.y += item.speed;
                mctx.font = item.type === 'bomb' ? '30px serif' : '25px serif';
                mctx.textAlign = 'center';
                mctx.fillText(item.type === 'bomb' ? 'üí£' : 'üåë', item.x, item.y);
                if (item.y > 440 && item.y < 480 && Math.abs(item.x - miniOtterX) < 35) {
                    if (item.type === 'bomb') miniGameOver = true;
                    else { miniScore++; miniItems.splice(index, 1); }
                }
                if (item.y > 520) miniItems.splice(index, 1);
            });
            mctx.font = '50px serif';
            mctx.textAlign = 'center';
            mctx.fillText('ü¶¶', miniOtterX, 480);
        }

        function updateReflex() {
            reflexTimer++;
            if (!miniGameOver && reflexTimer % Math.floor(reflexSpawnRate) === 0) {
                reflexTargets.push({
                    x: Math.random() * 300 + 50,
                    y: Math.random() * 350 + 80,
                    life: 100,
                    type: Math.random() < 0.2 ? 'bomb' : 'stone',
                    size: 30 + Math.random() * 20
                });
                if (reflexSpawnRate > 40) reflexSpawnRate *= 0.98;
            }
            reflexTargets.forEach((t, index) => {
                t.life -= REFLEX_DECAY;
                if (t.life <= 0) {
                    if (t.type === 'stone') miniGameOver = true;
                    reflexTargets.splice(index, 1);
                    return;
                }
                mctx.globalAlpha = t.life / 100;
                mctx.font = `${t.size}px serif`;
                mctx.textAlign = 'center';
                mctx.fillText(t.type === 'bomb' ? 'üí£' : 'üåë', t.x, t.y);
                mctx.globalAlpha = 1.0;
                mctx.beginPath();
                mctx.strokeStyle = t.type === 'bomb' ? '#ff4757' : '#2ecc71';
                mctx.arc(t.x, t.y - t.size/3, t.size/2 + 5, 0, Math.PI * 2 * (t.life/100));
                mctx.stroke();
            });
        }

        function updateVoid() {
            voidTimer++;
            if (!miniGameOver && voidTimer % 90 === 0) {
                const gapSize = Math.max(90, 130 - miniScore); // SLIGHTLY LARGER GAP
                const gap = Math.random() * (400 - gapSize - 40) + 20;
                voidLasers.push({ y: -20, gap: gap, gapSize: gapSize });
            }
            voidLasers.forEach((l, index) => {
                l.y += VOID_SPEED; // SLIGHTLY SLOWER
                mctx.fillStyle = "#ff4757";
                mctx.fillRect(0, l.y, l.gap, 8);
                mctx.fillRect(l.gap + l.gapSize, l.y, 400 - (l.gap + l.gapSize), 8);
                
                if (l.y > mouseY - 10 && l.y < mouseY + 10) {
                    if (mouseX < l.gap || mouseX > l.gap + l.gapSize) miniGameOver = true;
                    else if (!l.passed) { l.passed = true; miniScore += 5; }
                }
                if (l.y > 520) voidLasers.splice(index, 1);
            });
            mctx.fillStyle = "#3498db";
            mctx.beginPath(); mctx.arc(mouseX, mouseY, 10, 0, Math.PI*2); mctx.fill();
        }

        function updateMeteorStrike() {
            const centerX = 200, centerY = 250;
            const shieldRadius = 60;
            const planetRadius = 30;

            // Rotate shield based on mouse
            shieldAngle = Math.atan2(mouseY - centerY, mouseX - centerX);

            // Spawn Meteors
            meteorSpawnTimer++;
            if (!miniGameOver && meteorSpawnTimer % 75 === 0) { // SLIGHTLY SLOWER SPAWN
                const angle = Math.random() * Math.PI * 2;
                meteors.push({
                    x: centerX + Math.cos(angle) * 400,
                    y: centerY + Math.sin(angle) * 400,
                    speed: 1.2 + Math.random() * 1.0, // SLIGHTLY SLOWER METEORS
                    angle: angle + Math.PI // Direction to center
                });
            }

            // Draw Planet
            mctx.fillStyle = "#2ecc71";
            mctx.beginPath(); mctx.arc(centerX, centerY, planetRadius, 0, Math.PI*2); mctx.fill();
            mctx.strokeStyle = "rgba(255,255,255,0.3)";
            mctx.beginPath(); mctx.arc(centerX, centerY, planetRadius + 5, 0, Math.PI*2); mctx.stroke();

            // Draw Shield Arc
            mctx.strokeStyle = "#3498db";
            mctx.lineWidth = 10; // THICKER SHIELD
            mctx.lineCap = "round";
            mctx.beginPath();
            mctx.arc(centerX, centerY, shieldRadius, shieldAngle - 0.5, shieldAngle + 0.5);
            mctx.stroke();

            // Update & Draw Meteors
            meteors.forEach((m, index) => {
                m.x += Math.cos(m.angle) * m.speed;
                m.y += Math.sin(m.angle) * m.speed;

                const dist = Math.hypot(m.x - centerX, m.y - centerY);
                
                // Collision with shield
                if (dist < shieldRadius + 5 && dist > shieldRadius - 5) {
                    const meteorAngle = Math.atan2(m.y - centerY, m.x - centerX);
                    let angleDiff = Math.abs(meteorAngle - shieldAngle);
                    while(angleDiff > Math.PI) angleDiff = Math.abs(angleDiff - Math.PI * 2);

                    if (angleDiff < 0.6) {
                        miniScore += 2;
                        meteors.splice(index, 1);
                        return;
                    }
                }

                // Collision with planet
                if (dist < planetRadius) {
                    miniGameOver = true;
                }

                mctx.fillStyle = "#e74c3c";
                mctx.beginPath(); mctx.arc(m.x, m.y, 6, 0, Math.PI*2); mctx.fill();
            });
        }

        // Input Handling
        miniCanvas.addEventListener('mousemove', e => {
            if (!minigameActive) return;
            const rect = miniCanvas.getBoundingClientRect();
            mouseX = Math.max(0, Math.min(400, e.clientX - rect.left));
            mouseY = Math.max(0, Math.min(500, e.clientY - rect.top));
            
            if (currentMiniGameType === 'otter') miniOtterX = mouseX;
        });

        miniCanvas.addEventListener('mousedown', e => {
            if (!minigameActive) return;
            if (miniGameOver) { resetMiniState(); return; }
            if (currentMiniGameType === 'reflex') {
                const rect = miniCanvas.getBoundingClientRect();
                const mx = e.clientX - rect.left, my = e.clientY - rect.top;
                let hit = false;
                reflexTargets.forEach((t, index) => {
                    if (Math.hypot(mx - t.x, my - t.y) < t.size) {
                        hit = true;
                        if (t.type === 'bomb') miniGameOver = true;
                        else { miniScore += 5; reflexTargets.splice(index, 1); }
                    }
                });
                if (!hit && !miniGameOver) miniScore = Math.max(0, miniScore - 2);
            }
        });

        function launchOtters() {
            for (let i = 0; i < 12; i++) {
                setTimeout(() => {
                    const o = document.createElement('div');
                    o.className = 'otter-anim';
                    o.textContent = 'ü¶¶';
                    o.style.left = '-100px';
                    o.style.top = Math.random() * 90 + 'vh';
                    o.style.animation = `otter-run ${3 + Math.random() * 2}s linear forwards`;
                    fxContainer.appendChild(o);
                    setTimeout(() => o.remove(), 5000);
                }, i * 400);
            }
        }

        function launchTrophies() {
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const t = document.createElement('div');
                    t.className = 'trophy-item';
                    t.textContent = ['üèÜ','‚≠ê','‚ú®','üî•'][Math.floor(Math.random()*4)];
                    t.style.left = Math.random() * 90 + 'vw';
                    t.style.animation = `trophy-fall ${2 + Math.random() * 2}s linear forwards`;
                    fxContainer.appendChild(t);
                    setTimeout(() => t.remove(), 4000);
                }, i * 100);
            }
        }

        function openNickModal(side) {
            if (side === 'white' && isAiMode) return;
            const m = document.getElementById('nick-modal');
            const input = document.getElementById('nick-input');
            input.value = playerStats[side].name;
            m.style.display = 'flex';
            document.getElementById('nick-save').onclick = () => {
                playerStats[side].name = input.value.trim() || `Player ${side==='black'?'1':'2'}`;
                saveLocal(); updateUI(); closeModals();
            };
        }

        function closeModals() { document.querySelectorAll('.modal').forEach(m => m.style.display = 'none'); }

        function resetGame() {
            boardState = Array(SIZE).fill(null).map(() => Array(SIZE).fill(null));
            gameActive = true;
            currentPlayer = 'black';
            closeModals();
            initBoard();
            updateUI();
        }

        function clearStats() {
            const confirmed = window.confirm("Clear all points and names?");
            if (confirmed) {
                playerStats = { 
                    black: { name: "Player 1", points: 0 }, 
                    white: { name: isAiMode ? "AI Bot" : "Player 2", points: 0 } 
                };
                saveLocal(); updateUI();
            }
        }

        document.getElementById('reset-btn').onclick = resetGame;
        document.getElementById('giveup-btn').onclick = () => gameActive && endGame(currentPlayer === 'black' ? 'white' : 'black', WIN_GAIN);
        document.getElementById('draw-btn').onclick = offerDraw;

        window.onload = () => { initBoard(); updateUI(); };
    </script>
</body>
</html>
